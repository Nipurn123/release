{"version":3,"sources":["out-vscode-reh-web/vs/workbench/contrib/webview/browser/pre/service-worker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// @ts-check\n\n/// <reference lib=\"webworker\" />\n\nconst sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {any} */ (self));\n\nconst VERSION = 4;\n\nconst resourceCacheName = `vscode-resource-cache-${VERSION}`;\n\nconst rootPath = sw.location.pathname.replace(/\\/service-worker.js$/, '');\n\nconst searchParams = new URL(location.toString()).searchParams;\n\nconst remoteAuthority = searchParams.get('remoteAuthority');\n\nconst ID = searchParams.get('id');\n\n/**\n * Origin used for resources\n */\nconst resourceBaseAuthority = searchParams.get('vscode-resource-base-authority');\n\nconst resolveTimeout = 30_000;\n\n/**\n * @template T\n * @typedef {{ status: 'ok'; value: T } | { status: 'timeout' }} RequestStoreResult\n */\n\n/**\n * @template T\n * @typedef {{\n *     resolve: (x: RequestStoreResult<T>) => void,\n *     promise: Promise<RequestStoreResult<T>>\n * }} RequestStoreEntry\n */\n\n/**\n * Caches\n * @template T\n */\nclass RequestStore {\n\tconstructor() {\n\t\t/** @type {Map<number, RequestStoreEntry<T>>} */\n\t\tthis.map = new Map();\n\n\t\tthis.requestPool = 0;\n\t}\n\n\t/**\n\t * @returns {{ requestId: number, promise: Promise<RequestStoreResult<T>> }}\n\t */\n\tcreate() {\n\t\tconst requestId = ++this.requestPool;\n\n\t\t/** @type {undefined | ((x: RequestStoreResult<T>) => void)} */\n\t\tlet resolve;\n\n\t\t/** @type {Promise<RequestStoreResult<T>>} */\n\t\tconst promise = new Promise(r => resolve = r);\n\n\t\t/** @type {RequestStoreEntry<T>} */\n\t\tconst entry = { resolve: /** @type {(x: RequestStoreResult<T>) => void} */ (resolve), promise };\n\n\t\tthis.map.set(requestId, entry);\n\n\t\tconst dispose = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tconst existingEntry = this.map.get(requestId);\n\t\t\tif (existingEntry === entry) {\n\t\t\t\texistingEntry.resolve({ status: 'timeout' });\n\t\t\t\tthis.map.delete(requestId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\t\tconst timeout = setTimeout(dispose, resolveTimeout);\n\t\treturn { requestId, promise };\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @param {T} result\n\t * @return {boolean}\n\t */\n\tresolve(requestId, result) {\n\t\tconst entry = this.map.get(requestId);\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\t\tentry.resolve({ status: 'ok', value: result });\n\t\tthis.map.delete(requestId);\n\t\treturn true;\n\t}\n}\n\n/**\n * @typedef {{ readonly status: 200; id: number; path: string; mime: string; data: Uint8Array; etag: string | undefined; mtime: number | undefined; }\n * \t\t| { readonly status: 304; id: number; path: string; mime: string; mtime: number | undefined }\n *\t\t| { readonly status: 401; id: number; path: string }\n *\t\t| { readonly status: 404; id: number; path: string }} ResourceResponse\n */\n\n/**\n * Map of requested paths to responses.\n *\n * @type {RequestStore<ResourceResponse>}\n */\nconst resourceRequestStore = new RequestStore();\n\n/**\n * Map of requested localhost origins to optional redirects.\n *\n * @type {RequestStore<string | undefined>}\n */\nconst localhostRequestStore = new RequestStore();\n\nconst unauthorized = () =>\n\tnew Response('Unauthorized', { status: 401, });\n\nconst notFound = () =>\n\tnew Response('Not Found', { status: 404, });\n\nconst methodNotAllowed = () =>\n\tnew Response('Method Not Allowed', { status: 405, });\n\nconst requestTimeout = () =>\n\tnew Response('Request Timeout', { status: 408, });\n\nsw.addEventListener('message', async (event) => {\n\tswitch (event.data.channel) {\n\t\tcase 'version': {\n\t\t\tconst source = /** @type {Client} */ (event.source);\n\t\t\tsw.clients.get(source.id).then(client => {\n\t\t\t\tif (client) {\n\t\t\t\t\tclient.postMessage({\n\t\t\t\t\t\tchannel: 'version',\n\t\t\t\t\t\tversion: VERSION\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tcase 'did-load-resource': {\n\t\t\t/** @type {ResourceResponse} */\n\t\t\tconst response = event.data.data;\n\t\t\tif (!resourceRequestStore.resolve(response.id, response)) {\n\t\t\t\tconsole.log('Could not resolve unknown resource', response.path);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcase 'did-load-localhost': {\n\t\t\tconst data = event.data.data;\n\t\t\tif (!localhostRequestStore.resolve(data.id, data.location)) {\n\t\t\t\tconsole.log('Could not resolve unknown localhost', data.origin);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.log('Unknown message');\n\t\t\treturn;\n\t\t}\n\t}\n});\n\nsw.addEventListener('fetch', (event) => {\n\tconst requestUrl = new URL(event.request.url);\n\tif (typeof resourceBaseAuthority === 'string' && requestUrl.protocol === 'https:' && requestUrl.hostname.endsWith('.' + resourceBaseAuthority)) {\n\t\tswitch (event.request.method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'HEAD': {\n\t\t\t\tconst firstHostSegment = requestUrl.hostname.slice(0, requestUrl.hostname.length - (resourceBaseAuthority.length + 1));\n\t\t\t\tconst scheme = firstHostSegment.split('+', 1)[0];\n\t\t\t\tconst authority = firstHostSegment.slice(scheme.length + 1); // may be empty\n\t\t\t\treturn event.respondWith(processResourceRequest(event, {\n\t\t\t\t\tscheme,\n\t\t\t\t\tauthority,\n\t\t\t\t\tpath: requestUrl.pathname,\n\t\t\t\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\t\t\t}));\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn event.respondWith(methodNotAllowed());\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we're making a request against the remote authority, we want to go\n\t// through VS Code itself so that we are authenticated properly.  If the\n\t// service worker is hosted on the same origin we will have cookies and\n\t// authentication will not be an issue.\n\tif (requestUrl.origin !== sw.origin && requestUrl.host === remoteAuthority) {\n\t\tswitch (event.request.method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'HEAD': {\n\t\t\t\treturn event.respondWith(processResourceRequest(event, {\n\t\t\t\t\tpath: requestUrl.pathname,\n\t\t\t\t\tscheme: requestUrl.protocol.slice(0, requestUrl.protocol.length - 1),\n\t\t\t\t\tauthority: requestUrl.host,\n\t\t\t\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\t\t\t}));\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn event.respondWith(methodNotAllowed());\n\t\t\t}\n\t\t}\n\t}\n\n\t// See if it's a localhost request\n\tif (requestUrl.origin !== sw.origin && requestUrl.host.match(/^(localhost|127.0.0.1|0.0.0.0):(\\d+)$/)) {\n\t\treturn event.respondWith(processLocalhostRequest(event, requestUrl));\n\t}\n});\n\nsw.addEventListener('install', (event) => {\n\tevent.waitUntil(sw.skipWaiting()); // Activate worker immediately\n});\n\nsw.addEventListener('activate', (event) => {\n\tevent.waitUntil(sw.clients.claim()); // Become available to all pages\n});\n\n/**\n * @param {FetchEvent} event\n * @param {{\n * \t\tscheme: string;\n * \t\tauthority: string;\n * \t\tpath: string;\n * \t\tquery: string;\n * }} requestUrlComponents\n */\nasync function processResourceRequest(event, requestUrlComponents) {\n\tconst client = await sw.clients.get(event.clientId);\n\tlet webviewId;\n\tif (!client) {\n\t\tconst workerClient = await getWorkerClientForId(event.clientId);\n\t\tif (!workerClient) {\n\t\t\tconsole.error('Could not find inner client for request');\n\t\t\treturn notFound();\n\t\t} else {\n\t\t\twebviewId = getWebviewIdForClient(workerClient);\n\t\t}\n\t} else {\n\t\twebviewId = getWebviewIdForClient(client);\n\t}\n\n\tif (!webviewId) {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn notFound();\n\t}\n\n\tconst shouldTryCaching = (event.request.method === 'GET');\n\n\t/**\n\t * @param {RequestStoreResult<ResourceResponse>} result\n\t * @param {Response | undefined} cachedResponse\n\t */\n\tconst resolveResourceEntry = (result, cachedResponse) => {\n\t\tif (result.status === 'timeout') {\n\t\t\treturn requestTimeout();\n\t\t}\n\n\t\tconst entry = result.value;\n\t\tif (entry.status === 304) { // Not modified\n\t\t\tif (cachedResponse) {\n\t\t\t\treturn cachedResponse.clone();\n\t\t\t} else {\n\t\t\t\tthrow new Error('No cache found');\n\t\t\t}\n\t\t}\n\n\t\tif (entry.status === 401) {\n\t\t\treturn unauthorized();\n\t\t}\n\n\t\tif (entry.status !== 200) {\n\t\t\treturn notFound();\n\t\t}\n\n\t\t/** @type {Record<string, string>} */\n\t\tconst commonHeaders = {\n\t\t\t'Access-Control-Allow-Origin': '*',\n\t\t};\n\n\t\tconst byteLength = entry.data.byteLength;\n\n\t\tconst range = event.request.headers.get('range');\n\t\tif (range) {\n\t\t\t// To support seeking for videos, we need to handle range requests\n\t\t\tconst bytes = range.match(/^bytes\\=(\\d+)\\-(\\d+)?$/g);\n\t\t\tif (bytes) {\n\t\t\t\t// TODO: Right now we are always reading the full file content. This is a bad idea\n\t\t\t\t// for large video files :)\n\n\t\t\t\tconst start = Number(bytes[1]);\n\t\t\t\tconst end = Number(bytes[2]) || byteLength - 1;\n\t\t\t\treturn new Response(entry.data.slice(start, end + 1), {\n\t\t\t\t\tstatus: 206,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...commonHeaders,\n\t\t\t\t\t\t'Content-range': `bytes 0-${end}/${byteLength}`,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// We don't understand the requested bytes\n\t\t\t\treturn new Response(null, {\n\t\t\t\t\tstatus: 416,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...commonHeaders,\n\t\t\t\t\t\t'Content-range': `*/${byteLength}`\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Record<string, string>} */\n\t\tconst headers = {\n\t\t\t...commonHeaders,\n\t\t\t'Content-Type': entry.mime,\n\t\t\t'Content-Length': byteLength.toString(),\n\t\t};\n\n\t\tif (entry.etag) {\n\t\t\theaders['ETag'] = entry.etag;\n\t\t\theaders['Cache-Control'] = 'no-cache';\n\t\t}\n\t\tif (entry.mtime) {\n\t\t\theaders['Last-Modified'] = new Date(entry.mtime).toUTCString();\n\t\t}\n\n\t\t// support COI requests, see network.ts#COI.getHeadersFromQuery(...)\n\t\tconst coiRequest = new URL(event.request.url).searchParams.get('vscode-coi');\n\t\tif (coiRequest === '3') {\n\t\t\theaders['Cross-Origin-Opener-Policy'] = 'same-origin';\n\t\t\theaders['Cross-Origin-Embedder-Policy'] = 'require-corp';\n\t\t} else if (coiRequest === '2') {\n\t\t\theaders['Cross-Origin-Embedder-Policy'] = 'require-corp';\n\t\t} else if (coiRequest === '1') {\n\t\t\theaders['Cross-Origin-Opener-Policy'] = 'same-origin';\n\t\t}\n\n\t\tconst response = new Response(entry.data, {\n\t\t\tstatus: 200,\n\t\t\theaders\n\t\t});\n\n\t\tif (shouldTryCaching && entry.etag) {\n\t\t\tcaches.open(resourceCacheName).then(cache => {\n\t\t\t\treturn cache.put(event.request, response);\n\t\t\t});\n\t\t}\n\t\treturn response.clone();\n\t};\n\n\tconst parentClients = await getOuterIframeClient(webviewId);\n\tif (!parentClients.length) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\t/** @type {Response | undefined} */\n\tlet cached;\n\tif (shouldTryCaching) {\n\t\tconst cache = await caches.open(resourceCacheName);\n\t\tcached = await cache.match(event.request);\n\t}\n\n\tconst { requestId, promise } = resourceRequestStore.create();\n\n\tfor (const parentClient of parentClients) {\n\t\tparentClient.postMessage({\n\t\t\tchannel: 'load-resource',\n\t\t\tid: requestId,\n\t\t\tscheme: requestUrlComponents.scheme,\n\t\t\tauthority: requestUrlComponents.authority,\n\t\t\tpath: requestUrlComponents.path,\n\t\t\tquery: requestUrlComponents.query,\n\t\t\tifNoneMatch: cached?.headers.get('ETag'),\n\t\t});\n\t}\n\n\treturn promise.then(entry => resolveResourceEntry(entry, cached));\n}\n\n/**\n * @param {FetchEvent} event\n * @param {URL} requestUrl\n * @return {Promise<Response>}\n */\nasync function processLocalhostRequest(event, requestUrl) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\t// This is expected when requesting resources on other localhost ports\n\t\t// that are not spawned by vs code\n\t\treturn fetch(event.request);\n\t}\n\tconst webviewId = getWebviewIdForClient(client);\n\tif (!webviewId) {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn fetch(event.request);\n\t}\n\n\tconst origin = requestUrl.origin;\n\n\t/**\n\t * @param {RequestStoreResult<string | undefined>} result\n\t * @return {Promise<Response>}\n\t */\n\tconst resolveRedirect = async (result) => {\n\t\tif (result.status !== 'ok' || !result.value) {\n\t\t\treturn fetch(event.request);\n\t\t}\n\n\t\tconst redirectOrigin = result.value;\n\t\tconst location = event.request.url.replace(new RegExp(`^${requestUrl.origin}(/|$)`), `${redirectOrigin}$1`);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: location\n\t\t\t}\n\t\t});\n\t};\n\n\tconst parentClients = await getOuterIframeClient(webviewId);\n\tif (!parentClients.length) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\tconst { requestId, promise } = localhostRequestStore.create();\n\tfor (const parentClient of parentClients) {\n\t\tparentClient.postMessage({\n\t\t\tchannel: 'load-localhost',\n\t\t\torigin: origin,\n\t\t\tid: requestId,\n\t\t});\n\t}\n\n\treturn promise.then(resolveRedirect);\n}\n\n/**\n * @param {Client} client\n * @returns {string | null}\n */\nfunction getWebviewIdForClient(client) {\n\t// Refs https://github.com/microsoft/vscode/issues/244143\n\t// With PlzDedicatedWorker, worker subresources and blob wokers\n\t// will use clients different from the window client.\n\t// Since we cannot different a worker main resource from a worker subresource\n\t// we will use the global webview ID passed in at the time of\n\t// service worker registration.\n\tif (client.type === 'worker' || client.type === 'sharedworker') {\n\t\treturn ID;\n\t}\n\tconst requesterClientUrl = new URL(client.url);\n\treturn requesterClientUrl.searchParams.get('id');\n}\n\n/**\n * @param {string} webviewId\n * @returns {Promise<Client[]>}\n */\nasync function getOuterIframeClient(webviewId) {\n\tconst allClients = await sw.clients.matchAll({ includeUncontrolled: true });\n\treturn allClients.filter(client => {\n\t\tconst clientUrl = new URL(client.url);\n\t\tconst hasExpectedPathName = (clientUrl.pathname === `${rootPath}/` || clientUrl.pathname === `${rootPath}/index.html` || clientUrl.pathname === `${rootPath}/index-no-csp.html`);\n\t\treturn hasExpectedPathName && clientUrl.searchParams.get('id') === webviewId;\n\t});\n}\n\n/**\n * @param {string} clientId\n * @returns {Promise<Client|undefined>}\n */\nasync function getWorkerClientForId(clientId) {\n\tconst allDedicatedWorkerClients = await sw.clients.matchAll({ type: 'worker' });\n\tconst allSharedWorkerClients = await sw.clients.matchAll({ type: 'sharedworker' });\n\tconst allWorkerClients = [...allDedicatedWorkerClients, ...allSharedWorkerClients];\n\treturn allWorkerClients.find(client => {\n\t\treturn client.id === clientId;\n\t});\n}\n"],"mappings":"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","names":["requestId","resolve","promise","r","entry","timeout","existingEntry","result","event","source","client","response","data","requestUrl","firstHostSegment","scheme","authority","requestUrlComponents","webviewId","workerClient","shouldTryCaching","resolveResourceEntry","cachedResponse","commonHeaders","byteLength","range","bytes","start","end","headers","coiRequest","cache","parentClients","cached","parentClient","origin","resolveRedirect","redirectOrigin","location","clientUrl","clientId","allDedicatedWorkerClients","allSharedWorkerClients"],"file":"service-worker.js"}